\section{Modèle d'exécution fluxionnel}

\subsection{Fluxions}

Comme pour les autres systèmes scalables, le principe de modèle d'exécution
fluxionnel est d'identifier des unités
d'exécution autonomes fondées exclusivement sur des flux comme paramètre
d'entrée et de sortie des unités.  Une unité est autonome quand
elle peut être déplacée dynamiquement d'environnement d'exécution au cours
de son activité.  Déplacer une unité nécessite de déplacer
avec son code d'exécution son contexte d'exécution courant, c'est à dire l'ensemble des
variables de mémoire dont dépend l'unité. Dans notre approche, le contexte est
capturé dans flux spécifique réinjecté dans l'unité à chaque d'exécution. 
Ainsi, déplacer une telle unité consiste à déplacer le code fonctionnel
vers une nouvelle destination, puis à rediriger les flux d'entrées et de
sorties en conséquence. L'état, les paramètres d'appel et les paramètres
de retour étant capturé dans des flux, on a une estimation instantané du coup
de déplacement de la fonction, proportionnel au débit des flux concernés. 

Nous avons appelé cette unité d'exécution autonome une fluxion. C'est à
dire une fonction, au sens de la programmation fonctionnelle, dépendant
exclusivement de flux de données.

\subsection{Plateforme de fluxions}

Une application fluxionnelle est composée d'un enchaînement de fluxions.
Chaque fluxion présente le même comportement :
\begin{itemize}
  \item elle est invoquée par un système de messagerie,
  \item elle effectue des opérations à partir du message reçu,
  \item elle modifie son état interne rendu persistant dans le système de messagerie
  \item puis elle retourne un ensemble de messages à destination d'autres
    fluxions.
\end{itemize}

Dans notre approche, un message est une structure clé/valeur
contenant deux couples : le nom de la fluxion à invoquer \textit{name} et le
corps du message \textit{body}, contenant l'ensemble clé/valeur des
attributs nécessaires à l'exécution de la fonction. 

Le système de messagerie repose sur uniquement deux fonctions publiques :
\begin{itemize}
  \item l'enregistrement de fluxion\\
    \texttt{register(<nom>, <fn>, <contexte>)}
  \item le démarrage d'une chaîne de traitements\\
    \texttt{start(<nom>,<param>)}
\end{itemize}

Les données et la logique d'une application sont cloisonnés
à l'exécution, il est possible de mettre à jour une
fluxion en la remplaçant dans le système, sans impacter l'exécution de
l'application. De plus déplacer une fluxion ne nécessite pas de la
supprimer de son n\oe ud initial, car seul la réception de message
déclenche une exécution. 

La relocalisation d'une fluxion se fait de manière transparente
par l'application, par le système de messagerie qui connaît la
localisation des fluxions. 

\subsection{Architecture Web}

Le système fluxionnel ne manipule que des fluxion par l'intermédiaire d'un
système de messagerie. Afin de pouvoir interagir avec le monde extérieur,
il faut définir des interfaces de bordure. Notre approche repose sur une
espérance de gain technologique principalement sur les architectures Web.
Le premier point d'entré visé est l'intégration des interfaces REST.  Le
schéma~\ref{xxx:xxx} présente les éléments d'un système Web fluxionnel.

\TODO{schema}

Le système Web est donc le déclencheur d'une chaîne de traitement de
requêtes à chaque nouvelle requête d'un utilisateur un appel à la fonction
\lstinline|start('/', <param>)| est réalisé dans le système de messagerie.
Au démarrage du système Web, deux demi-fluxions sont lancées.  La
demi-fluxion 'in' n'est pas enregistré dans le système de messagerie.
Elle prend les paramètres de la requête Web, place l'identifiant de la
connexion client dans le contexte de la demi-fluxion de sortie, puis lance
le traitement de la requête en invoquant la fonction `start` du système de
messagerie.

