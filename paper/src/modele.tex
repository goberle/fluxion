\section{Modèle d'exécution fluxionnel}

\subsection{Fluxions}

Le modèle d'exécution fluxionnel à pour fonction de manipuler et d'invoquer des unités d'exécution autonomes n'ayant pour paramètre d'entrée et de sortie que des flux, c'est à dire des séquences continues et infinies de données agrégés par messages.
Nous avons appelé ce type d'unité d'exécution autonome une fluxion.
C'est à dire une fonction, au sens de la programmation fonctionnelle, dépendant exclusivement de flux de données.
Elle est composée d'un nom unique, d'une fonction de traitement, et d'un contexte mémoire au moment de son exécution.

Les entrées et sorties d'une fluxion sont des flux.
Un flux est un ensemble de messages à destination d'une fluxion.
Les messages sont composés du nom de la fluxion destinataire et d'un corps.
Ils représentent à la fois le signal d'invocation, et les données nécessaires à cette invocation.
Après avoir traité un message, la fonction de traitement modifie son contexte local, puis termine son exécution en renvoyant un message sur son flux de sortie.

Les fluxions forment des chaînes de traitement liés par les flux, eux-même acheminés par un système de messagerie d'écrit plus bas.
Les fluxions sont organisés en un graphe dirigé.
Chaque fluxion renvoie un message unique à destination d'une ou plusieurs fluxions.

Le contexte d'exécution de la fonction de traitement est l'ensemble des variables de mémoire dont dépend la fluxion pour poursuivre un traitement entre deux exécutions.

\subsection{Système de messagerie}

Le système de messagerie est le cœur du modèle d'exécution fluxionnel.
Il a pour fonction, à la fois d'acheminer les flux de messages entres les fluxions, et d'invoquer les fluxions.

Il est construit autour d'une file de message traité les uns après les autres.
L'utilisation d'une file de messages en attentes permet d'exécuter plusieurs chaîne de traitement en parallèle de manière équitable.
Le cycle de vie du système de messagerie est illustré dans la figure \ref{fig:messagerie}.

\begin{figure}[h!]
  \includegraphics[width=0.5\textwidth]{schema-message.pdf}
  \caption{Schema du système de messagerie}
  \label{fig:messagerie}
\end{figure}

Chaque fluxion dois être enregistré dans le système de messagerie.
Cet enregistrement associe une fonction de traitement à un nom, et un contexte d'exécution propre.
Le système de messagerie achemine les flux de messages en se basant sur les noms des fluxions.
C'est pourquoi il ne peut pas exister plusieurs fluxions ayant le même nom.
Lors de cet enregistrement, il est possible d'initialiser le contexte d'exécution.
L'enregistrement se fait à l'aide de la fonction \texttt{register(<nom>, <fn>, <contexte>)}.
Une fluxion peut elle-même enregistrer d'autres fluxions dynamiquement.

Pour déclencher une chaîne de fluxions un premier message est envoyé à destination d'une fluxion par l'intermédiaire du système de messagerie, en utilisant la fonction \texttt{start(<msg>)}, étape \circled{2} sur le schema \ref{fig:messagerie}.
Cette fonction va placer un premier message dans la file.
Le système exécute la fonction de traitement destinataire de ce premier message, étape \circled{3} sur le schema \ref{fig:messagerie}.
Le message résultat de cette exécution est alors empilé dans la file de message, étape \circled{4} sur le schema \ref{fig:messagerie}.

L'algorithme \ref{alg:traitement} explique précisément le traitement d'un message, et l'invocation de la fluxion destinataire décrit ci-dessus.
Tandis que l'algorithme \ref{alg:parcours} explique le parcours de la file de messages.

\begin{algorithm}
\caption{Algorithme de traitement de la file de messages}
\label{alg:traitement}
\begin{algorithmic}
\Function{ProcessMsg}{$msg$}
\For{$dest$ \textbf{in} $msg.dest$}
\State $flx \gets lookup(dest)$
\State $res \gets$ \Call{exec}{$flx, msg.body$} \Comment{étape \circled{3}}
\State \Call{enqueue}{$res$} \Comment{étape \circled{4}}
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algorithme de parcours de la file}
\label{alg:parcours}
\begin{algorithmic}
\Function{ProcessMsg}{$msg$}
\While{$msg$ \textbf{presents in} $msgQueue$}
\State $msg \gets$ \Call{dequeue}{\null}
\State \Call{ProcessMsg}{$msg$}
\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Interface}

Les fluxions ne peuvent échanger qu'à l'intérieur du modèle d'exécution.
Afin de pouvoir interagir avec le monde extérieur, il faut définir des interfaces de bordure.
Les bordures du systèmes sont des fluxions qui font l'interface avec l'extérieur du système.

Notre approche repose sur une espérance de gain technologique principalement sur les architectures Web.
Le premier point d'entré visé est l'intégration des interfaces REST, mais tout autre point d'entrée est valable tant qu'une interface de bordure en flux peut être défini.

Dans notre approche, il existe deux types de fluxion de bordures web :

\begin{itemize}
	\item[les \textbf{entrées}]
    permettent de recevoir des connections client entrantes suivant le protocole HTTP.
    C'est donc le premier maillon de la chaîne de traitement.
    Pour chaque connexion entrante, l'entrée va générer une bordure de sortie permettant de répondre au client.
	\item[les \textbf{sorties}]
    permettent d'envoyer le résultat de la chaîne de traitement au client.
    C'est donc le dernier maillon de la chaîne de traitement.
\end{itemize}


Le schéma \ref{fig:schemaweb} présente les éléments d'un système Web fluxionnel et détaille les étapes d'acheminement d'un message par le système de messagerie.

\begin{figure}[h!]
	\includegraphics[width=0.5\textwidth]{schema-web.pdf}
	\caption{Schema d'un système fluxionnel avec une interface web}
	\label{fig:schemaweb}
\end{figure}

Le système Web est donc le déclencheur d'une chaîne de traitement de requêtes à chaque nouvelle requête d'un utilisateur un appel à la fonction \lstinline|start('/', <param>)| est réalisé dans le système de messagerie.
Au démarrage du système Web, deux fluxions de bordure sont lancées.
La fluxion de bordure 'in' n'est pas enregistré dans le système de messagerie.
Elle prend les paramètres de la requête Web, place l'identifiant de la connexion client dans le contexte de la demi-fluxion de sortie, puis lance le traitement de la requête en invoquant la fonction `start` du système de messagerie.

\subsection{Exemple de fluxion}

Afin d'illustrer le modèle d'exécution fluxionnel, nous présentons ici un exemple de son utilisation à travers un simple service de comptage de visite.

Ce service permet de compter le nombre de connexions HTTP de chaque utilisateur sur ce service et renvoie le résultat sous forme d'une réponse HTTP.

Le code \ref{lst:classique} représente le code de ce service de comptage dans un modèle classique.

\begin{figure}
  \begin{code}
  var app = require('express')();

  var count = {};

  app.get('/:id', function(req, res){
    res.send(req.params.id + '[' + (count[req.params.id] = (count[req.params.id] + 1) || 1 ) + ']');
  });

  port = 8080;
  app.listen(port);
  console.log("Listening port: "+port);
  \end{code}
  \caption{Code classique}
  \label{lst:classique}
\end{figure}

Le code \ref{lst:fluxionnel} représente le code de ce même service de comptage dans le modèle fluxionnel.

\begin{figure}
  \begin{code}
  var flx = require('./lib/flx')
    , express = require('express')
    , app = express();

  flx.register("output", function(msg){
    if (msg.res) {
      this.cid[msg.cid] = msg.res;
    } else {
      this.cid[msg.cid].send(msg.view.toString());
    }
    return undefined;
  }, {
    cid: {}
  })

  flx.register("input", function(msg){
    this.uid[msg.uid] = this.uid[msg.uid] + 1 || 1;
    msg.count = this.uid[msg.uid];
    return this.m("view", msg);
  },{
    uid: {}
  });

  flx.register("view", function(msg) {
    msg.view = msg.uid + "[" + msg.count + "]";
    msg.uid = undefined;
    msg.count = undefined;
    return this.m("output", msg);
  })

  app.get('/:id', function(req, res) {
    var uid = req.params.id;
    var cid = req.client._idleStart;

    flx.start(flx.m("output", {cid: cid, res: res}));
    flx.start(flx.m("input", {uid: uid, cid: cid}));
  })

  app.listen(8080);
  \end{code}
  \caption{Code fluxionnel}
  \label{lst:fluxionnel}
\end{figure}

La code classique est bien plus concis que le code fluxionnel du fait de la segmentation et de l'encapsulation  par le modèle fluxionnel.

Le service à été ségmenté comme suit :
\begin{itemize}
  \item Le point d'entrée \texttt{app.get} réagit à la connection d'un client et démarre la chaîne de traitement.
  Ce n'est pas une fluxion et il n'est pas enregistré dans le système de messagerie.
  \item Le point de sortie \texttt{output} est une fluxion mais elle est liée à la machine sur laquelle arrive la connexion afin de pouvoir y répondre.
  \item La fluxion \texttt{input} est la première à recevoir le message indiquant une connexion cliente. Son traitement consiste à incrémenter le compteur de l'utilisateur présent dans son scope, et à renseigner ce compteur dans le message, avant de le renvoyer à la fluxion suivante.
  \item La fluxion \texttt{view} récupère le message, et met en forme la réponse que recevra l'utilisateur, et l'envoie à la fluxion de sortie.
\end{itemize}

Les messages échangés contiennent principalement deux informations importantes : les identifiants d'utilisateurs, permettant d'incrémenter un compteur pour chaque utilisateur, et les identifiants de connexion, permettant de lier une suite de messages avec la structure contenant la connexion HTTP.
Le point d'entrée, et le point de sortie du système doivent rester sur la machine où la connexion a eu lieu pour avoir accès à l'interface réseau, tandis que les autre fluxions n'ont pas cette obligation, et peuvent être migré.


Cet identifiant de connexion est nécessaire au point de sortie pour associer le résultat reçu avec la connexion vers laquelle le renvoyer à l'utilisateur.
Nous passons cet identifiant pour ne pas alourdir les échanges de messages avec la structure contenant la connexion HTTP.

Ainsi, la fluxion de sortie reçois des messages provenant de deux fluxions : le point d'entrée




