\section{Introduction}


The growth of web platforms is caused partially by Internet's capacity to stimulate services development and allow very quick release of minimal viable products.
In a matter of hours, it's possible to upload a first product and start gathering a community around.
\textit{``Release early, release often''} is commonly heard as an advice to quickly gather a user community, as the size of the community is a factor of success.

If the service complies successfully with users requirements, the community will grow gradually as the service gain popularity.
To cope with this growth, the resources quantity taken up by the service shall grow exponentially.
Until the amount of data to process requires the development team to use a more efficient processing model to make better use of the resources.
Many of the most efficient models split the system into parts to reduce coupling and migrate them to more resourceful environment. [biblio]
Once split, the different service's parts are connected by a messaging system, often asynchronous, using communication paradigms like \textit{three-tiers} architecture, events, messages or stream.
Many tools have been developed to express and manage these different service's parts and their communications [Storm, MillWheel, Spark, TimeStream ...]
However these tools use specific interfaces and languages.
Thus, it requires the development team to be trained, to hire experts and to start over the initial code base, while this new architecture is not flexible and adaptable enough for quick modifications, as the initial code base was.
Thus, this modifications implies the development team to take risks without adding concrete value to the service.

We propose a tool able to automate this architecture shift.
Such a tool might lift the risks described above.
We aim at providing this tool to Web applications for which load come from users requests streams.
And application for which initial development use a simple web paradigm consisting of a web server, data processing logic, and a database.
We think it's possible to analyze this type of applications to express it using autonomous, movable functions communicating by data streams.
And to shift architecture as soon as the first public release without wiping off the initial code base.

We assume these applications are developed in a dynamic language like Javascript, and we propose a tool able to identify internal streams and stream processing units, and to dynamically manage these units.
The tool aims not to modify the existing code, but propose a layer of meta information over the initial code.
This layer uses the paradigm of fluxion which we are going to define in section 2, and will be at the core of our proposition of automation, described section 3.
In Section 4, we evaluate our tool, and compare it to other solutions in term of performance, and development impact.



% La croissance des plateformes du Web est dû partiellement à la capacité d'Internet à favoriser le développement de services avec une mise en production minimale très rapide.
% En quelques heures, il est possible de mettre en ligne un produit fonctionnel afin de rassembler une première audience.
% \textit{``Release early, release often''} est souvent entendu pour capter rapidement une communauté d'utilisateurs autour d'un projet open source.

% Si le service répond correctement aux attentes, l'audience va probablement grossir au fur et à mesure que le service gagne en popularité.
% Pour pouvoir faire face à cette croissance, la quantité de ressources utilisé par le service augmente en conséquence, et il arrive un moment dans le développement du produit où la taille des données à traiter et la quantité de ressources nécessaires, imposent l'utilisation d'un modèle de traitement plus efficace.
% La plupart des modèles plus efficaces passent par une segmentation des échanges entre fonctions, en utilisant différents paradigmes de communication comme les approches \textit{three-tiers}, les événements, les messages ou les flux, afin de réduire le couplage entre les parties et pouvoir les migrer vers des environnement de plus en plus puissants. [bilbio]
% Une fois segmenté, les différentes parties communiquent entre elles par un principe de messagerie le plus souvent asynchrone.
% De nombreux outils ont été définis qui permettent d'exprimer ces différentes parties, leurs interactions, et de prendre en charge l'acheminement des messages [Storm, MillWheel, Spark, TimeStream ...].
% Cependant, ces outils utilisent des interfaces et des langages particuliers.
% Il est nécessaire de former les équipes de développement à leur utilisation, d'engager des experts et de réécrire le code initial.
% Cette nouvelle architecture est globalement moins souple et souvent moins propice aux changements rapides, de ce fait le changement d'architecture présente une prise de risque dans la poursuite du projet de par les modifications impliqués sur le developpement, sans pour autant d'impact direct sur la nature du service rendu.
% // TODO à vérifier et documenter [biblio]

% Nous proposons un outil visant à automatiser ce changement d'architecture, en apportant une vision segmentée du programme sans modifier le code initalement développé.
% Un tel outil permettrait de lever les risques décrits ci-dessus.
% // TODO notion de lazy transformation
% Nous visons des applications Web dont les sollicitations proviennent des flux de requêtes utilisateurs et dont le développement initial est réalisé selon une approche web 'basique' (serveur web / traitement applicatif / data).
% Nous pensons qu'il est possible d'analyser cette classe d'applications dès les premières étapes d'exploitation afin de les exprimer sous la forme de flux échangés entre fonctions autonomes, relocalisables.

% Nous supposons que les applications sont développées dans un langage dynamique comme Javascript, et nous proposons un outil capable d'identifier les flux internes d'échanges, de définir des unités de traitement de ces flux, et de pouvoir gérer de manière dynamique ces unités.
% L'outil identifie ces unités sans être intrusif dans le code existant mais en proposant une sur-expression du programme initial reposant sur le paradigme de fluxion que nous allons définir et qui servira de cœur à notre proposition.